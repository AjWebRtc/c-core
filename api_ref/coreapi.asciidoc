= PubNub Posix C API Reference

* <<pubnub_init,pubnub_init >>
* <<pubnub_set_uuid,pubnub_set_uuid>>
* <<pubnub_uuid_get,pubnub_uuid_get>>
* <<pubnub_set_auth,pubnub_set_auth>>
* <<pubnub_auth_get,pubnub_auth_get>>
* <<pubnub_cancel,pubnub_cancel>>
* <<pubnub_publish,pubnub_publish>>
* <<pubnub_publishv2,pubnub_publishv2>>
* <<pubnub_get,pubnub_get>>
* <<pubnub_get_channel,pubnub_get_channel>>
* <<pubnub_subscribe,pubnub_subscribe>>
* <<pubnub_leave,pubnub_leave>>
* <<pubnub_time,pubnub_time>>
* <<pubnub_history,pubnub_history>>
* <<pubnub_historyv2,pubnub_historyv2>>
* <<pubnub_here_now,pubnub_here_now>>
* <<pubnub_global_here_now,pubnub_global_here_now>>
* <<pubnub_where_now,pubnub_where_now>>
* <<pubnub_set_state,pubnub_set_state>>
* <<pubnub_state_get,pubnub_state_get>>
* <<pubnub_remove_channel_group,pubnub_remove_channel_group>>
* <<pubnub_remove_channel_from_group,pubnub_remove_channel_from_group>>
* <<pubnub_add_channel_to_group,pubnub_add_channel_to_group>>
* <<pubnub_list_channel_group,pubnub_list_channel_group>>
* <<pubnub_last_result,pubnub_last_result>>
* <<pubnub_last_http_code,pubnub_last_http_code>>
* <<pubnub_last_publish_result,pubnub_last_publish_result>>
* <<pubnub_last_time_token,pubnub_last_time_token>>

== pubnub_init

===== void 	pubnub_init (pubnub_t *p, const char *publish_key, const char *subscribe_key)

===== DESCRIPTION
Initialize a given pubnub context p to the publish_key and subscribe_key.
You can customize other parameters of the context by the configuration function calls below.

The publish_key and subscribe key are expected to be valid (ASCIIZ string) pointers throughout the use of context p,
that is, until either you call pubnub_done(), or the otherwise stop using it (like when the whole software/ firmware 
stops working). So, the contents of these keys are not copied to the Pubnub context p.

This should be called after TCP initialization.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
|p        |pubnub_t* | Yes | Pointer to the Context to initialize (use pubnub_get_ctx() to obtain it)
|publish_key  | char * | Yes | Pointer to the string of the key to use when publishing messages
|subscribe_key  | char * | Yes | Pointer to the string of the key to use when subscribing to messages

|======================

===== RETURNS

[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| void |
|======================

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
```
===== OTHER EXAMPLES

== pubnub_set_uuid

===== void 	pubnub_set_uuid (pubnub_t *p, const char *uuid)

===== DESCRIPTION

Set the UUID identification of PubNub client context p to uuid. Pass NULL to unset.

NOTE: The uuid is expected to be valid (ASCIIZ string) pointers throughout the use of context p, that is, until either you call pubnub_done() on p, or the otherwise stop using it (like when the whole software/ firmware stops working). So, the contents of the uuid string is not copied to the Pubnub context p.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description 
| p | pubnub_t* | Yes | Pointer to pubnub context. 
| uuid | const char* | | Pointer to uuid string 
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| void |
|======================

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_set_uuid(ctx, "my_uuid");
```
===== OTHER EXAMPLES


== pubnub_uuid_get 

===== char const * 	pubnub_uuid_get (pubnub_t const *p)

===== DESCRIPTION

Get the UUID identification of PubNub client context p. After pubnub_init(), it will return NULL until you change it to non-NULL via pubnub_set_uuid().

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context.
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| char const* |
|======================

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_set_uuid(ctx, "my_uuid");
printf("UUID is %s", pubnub_get_uuid(ctx));
```
===== OTHER EXAMPLES

== pubnub_set_auth

===== void 	pubnub_set_auth(pubnub_t *p, const char *auth)

===== DESCRIPTION
Set the authentication information of PubNub client context p. Pass NULL to unset.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context
| auth | const char* | No | Pointer to auth string. NULL to unset
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| void |
|======================

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_set_auth(ctx, "my_auth_key");
```
===== OTHER EXAMPLES


== pubnub_auth_get

===== char const * pubnub_auth_get (pubnub_t const *p)


===== DESCRIPTION
Returns the current authentication information for the context p. After pubnub_init(), it will return NULL until you change it to non-NULL via pubnub_set_auth().

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t const* | Yes | Pointer to pubnub client context
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| char const* |
|======================

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_set_auth(ctx, "my_auth_key");
printf("Auth Key is %s", pubnub_auth_get(ctx));
```
===== OTHER EXAMPLES

== pubnub_cancel

===== void 	pubnub_cancel (pubnub_t *p)

===== DESCRIPTION
Cancel an ongoing API transaction. The outcome of the transaction in progress, if any, will be #PNR_CANCELLED.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to Pubnub Client Context.
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| void |
|======================

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_publish(ctx, “hello_world”, “\”Hello from Pubnub C-core docs!\””);
pubnub_cancel(ctx);
```

===== OTHER EXAMPLES


== pubnub_publish

===== enum pubnub_res pubnub_publish (pubnub_t *p, const char *channel, const char *message)

===== DESCRIPTION
Publish the message (in JSON format) on a channel, using the context. This actually means "initiate a publish transaction".

You can't publish if a transaction is in progress in p context.

If transaction is not successful (PNR_PUBLISH_FAILED), you can get the string describing the reason for failure by calling pubnub_last_publish_result().

Keep in mind that the time token from the publish operation response is not parsed by the library, just relayed to the user. Only time-tokens from the subscribe operation are parsed by the library.

Also, for all error codes known at the time of this writing, the HTTP error will be set also, so the result of the Pubnub operation will not be PNR_OK (but you will still be able to get the result code and the description).

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub context. Can't be NULL
| channel | const char* | Yes | Pointer to string with the channel name (or comma-delimited list of channel names) to publish to.
| message | const char* | Yes | Pointer to string containing message to publish in JSON format. 
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | PNR_STARTED on success, an error otherwise
|======================



===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_publish(ctx, “hello_world”, “\”Hello from Pubnub C-core docs!\””);
if (pbresult != PNR_STARTED) {
    printf(“Failed to publish, error %d\n”, pbresult);
    pubnub_free(ctx);
    return -1;
}
```

===== OTHER EXAMPLES

== pubnub_publishv2

===== enum pubnub_res pubnub_publishv2 (pubnub_t *p, const char *channel, const char *message, bool store_in_history, bool eat_after_reading)

===== DESCRIPTION
Publish the message (in JSON format) on a channel, using the context, utilizing the v2 API. This actually means "initiate a publish transaction".

Basically, this is an extension to the pubnub_publish() (v1), with some additional options.

You can't publish if a transaction is in progress in p context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to Pubnub Client Context
| channel | const char* | Yes | Pointer to string with the channel name (or comma-delimited list of channel names) to publish to.
| message | const char* | Yes | Pointer to string containing message to publish in JSON format. 
| store_in_history | bool | Yes | If false, message will not be stored in history of the channel
| eat_after_reading | bool | yes | If true, message will not be stored for delayed or repeated retrieval or display
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | PNR_STARTED on success, an error otherwise
|======================

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_publishv2(ctx, “hello_world”, “\”Hello from Pubnub C-core docs!\””, true, true);
if (pbresult != PNR_STARTED) {
    printf(“Failed to publish, error %d\n”, pbresult);
    pubnub_free(ctx);
    return -1;
}
```
===== OTHER EXAMPLES

== pubnub_get

===== char const * pubnub_get (pubnub_t *p)

===== DESCRIPTION
Returns a pointer to an arrived message or other element of the response to an operation/transaction. Message(s) arrive on finish of a subscribe operation or history operation, while for some other operations this will give access to the whole response, or the next element of the response. That is documented in the function that starts the operation.

Subsequent call to this function will return the next message (if any). All messages are from the channel(s) the last operation was for.

NOTE:   Context doesn't keep track of the channel(s) you subscribed to. This is a memory saving design decision, as most users won't change the channel(s) they subscribe too.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to Pubnub Client Context
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| char const* | Pointer to message. Can't be NULL.
|======================

===== BASIC USAGE
```
pubnub_subscribe(ctx, “hello_world”, NULL);
pbresult = pubnub_await(ctx);
if (pbresult != PNR_OK) {
    printf(“Failed to subscribe, error %d\n”, pbresult);
    pubnub_free(ctx);
    return -1;
}
else {
    char const *msg = pubnub_get(ctx);
    while (msg != NULL) {
        printf(“Got message: %s\n”, msg);
        msg = pubnub_get(ctx);
    }
}
pubnub_free(ctx);
```

===== OTHER EXAMPLES


== pubnub_get_channel

===== char const * 	pubnub_get_channel (pubnub_t *pb)

===== DESCRIPTION
Returns a pointer to an fetched subscribe operation/transaction's next channel. Each transaction may hold a list of channels, and this functions provides a way to read them. Subsequent call to this function will return the next channel (if any).

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| pb | pubnub_t* | Yes | Pointer to Pubnub Client Context. Can't be NULL.
|======================

===== RETURNS
char const*
Pointer to channel, NULL on error

===== BASIC USAGE
```
pubnub_subscribe(ctx, “hello_world”, NULL);
pbresult = pubnub_await(ctx);
if (pbresult != PNR_OK) {
    printf(“Failed to subscribe, error %d\n”, pbresult);
    pubnub_free(ctx);
    return -1;
}
else {
    char const *msg = pubnub_get(ctx);
    char const *channel = pubnub_get_channel(ctx);
    while (msg != NULL) {
        printf(“Got message: %s on channel %s\n”, msg, channel);
        msg = pubnub_get(ctx);
        channel = pubnub_get_channel(ctx);
    }
}
pubnub_free(ctx);
```
===== OTHER EXAMPLES

== pubnub_subscribe

===== enum pubnub_res pubnub_subscribe (pubnub_t *p, const char *channel, const char *channel_group)

===== DESCRIPTION
Subscribe to channel and/or channel_group. This actually means "initiate a subscribe operation/transaction". The outcome is sent to the process that starts the transaction via process event pubnub_publish_event, which is a good place to start reading the fetched message(s), via pubnub_get().

Messages published on channel and/or channel_group since the last subscribe transaction will be fetched.

The channel and channel_group strings may contain multiple comma-separated channel (channel group) names, so only one call is needed to fetch messages from multiple channels (channel groups).

If channel is NULL, then channel_group cannot be NULL and you will subscribe only to the channel group(s). It goes both ways: if channel_group is NULL, then channel cannot be NULL and you will subscribe only to the channel(s).

You can't subscribe if a transaction is in progress on the context.

Also, you can't subscribe if there are unread messages in the context (you read messages with pubnub_get()).

NOTE:   Some of the subscribed messages may be lost when calling publish() after a subscribe() on the same context or subscribe() on different channels in turn on the same context. But typically, you will want two separate contexts for publish and subscribe anyway. If you are changing the set of channels you subscribe to, you should first call pubnub_leave() on the old set.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to Pubnub client context. Can't be NULL.
| channel | const char* | No | The string with the channel name (or comma-delimited list of channel names) to subscribe to.
| channel_group | const char* | No | The string with the channel group name (or comma-delimited list of channel group names) to subscribe to.

|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | PNR_STARTED on success, an error otherwise
|======================

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_subscribe(ctx, “hello_world”, NULL);
pbresult = pubnub_await(ctx);
if (pbresult != PNR_OK) {
    printf(“Failed to subscribe, error %d\n”, pbresult);
    pubnub_free(ctx);
    return -1;
}
else {
    char const *msg = pubnub_get(ctx);
    char const *channel = pubnub_get_channel(ctx);
    while (msg != NULL) {
        printf(“Got message: %s on channel %s\n”, msg, channel);
        msg = pubnub_get(ctx);
        channel = pubnub_get_channel(ctx);
    }
}
pubnub_free(ctx);
```
===== OTHER EXAMPLES

== pubnub_leave

===== enum pubnub_res pubnub_leave (pubnub_t *p, const char *channel, const char *channel_group)

===== DESCRIPTION
Leave the channel. This actually means "initiate a leave transaction". You should leave channel(s) when you want to subscribe to another in the same context to avoid loosing messages. Also, it is useful for tracking presence.

You can't leave if a transaction is in progress on the context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to Pubnub client context. Can't be NULL.
| channel | const char* | No | The string with the channel name (or comma-delimited list of channel names) to leave from.
| channel_group | const char * | No | The string with the channel group name (or comma-delimited list of channel group names) to leave from.
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | PNR_STARTED on success, an error otherwise
|======================

===== BASIC USAGE
```
pubnub_leave(ctx, "hello_world", NULL);
pbresult = pubnub_await(ctx);
if (PNR_OK == pbresult) {
    printf("Leave successful\n");
}
pubnub_free(ctx);
```

===== OTHER EXAMPLES


== pubnub_time

===== enum pubnub_res pubnub_time (pubnub_t *p)

===== DESCRIPTION
Get the current Pubnub time token . This actually means "initiate a time transaction". Since time token is in the response to most Pubnub REST API calls, this is reserved mostly when you want to get a high-quality seed for a random number generator, or some such thing.

If transaction is successful, the gotten time will be the only message you can get with pubnub_get(). It will be a (large) JSON integer.

You can't get time if a transaction is in progress on the context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | PNR_STARTED on success, an error otherwise
|======================
===== BASIC USAGE
```
pubnub_time(ctx);
pbresult = pubnub_await(ctx);
if (PNR_OK == pbresult) {
    char const *gotten_time = pubnub_get();
}

```

===== OTHER EXAMPLES


== pubnub_history

===== enum pubnub_res pubnub_history (pubnub_t *p, const char *channel, const char *channel_group, unsigned count)

===== DESCRIPTION
Get the message history for the channel and/or channel_group. This actually means "initiate a history transaction".

If transaction is successful, the gotten messages will be available via the pubnub_get().

If channel is NULL, then channel_group cannot be NULL and you will get history only for the channel group. It goes both ways: if channel_group is NULL, then channel cannot be NULL and you will get history only for the channel.

You can't get history if a transaction is in progress on the context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context.
| channel | const char* | No | The string with the channel name to get message history for. This can't be a comma separated list of channels.
| channel_group | const char* | No | The string with the channel group name to get message history for. This can't be a comma separated list
| count | unsigned | Yes | Maximum number of messages to get. If there are less than this available on the channel, you'll get less, but you can't get more.
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | PNR_STARTED on success, an error otherwise
|======================

===== BASIC USAGE
```

unsigned count = 100; /* number of messages to retrieve */
pubnub_history(ctx, “my_channel”, NULL, count);
pbresult = pubnub_await(ctx);
if (PNR_OK == pbresult) {
    for (;;) {
        msg = pubnub_get(ctx);
        if (NULL == msg) {
            break;
        }
        puts(msg);
    }
}

```

===== OTHER EXAMPLES


== pubnub_historyv2

===== enum pubnub_res pubnub_historyv2 (pubnub_t *p, const char *channel, const char *channel_group, unsigned count, bool include_token)

===== DESCRIPTION
Get the message history for the channel and/or channel_group using the v2 API. This actually means "initiate a history transaction/operation".

If transaction is successful, the gotten messages will be available via the pubnub_get(), but in a different way then pubnub_history(). In our case, pubnub_get() will give you exactly three messages (or, rather, elements). The first will be a JSON array of gotten messages, and the second and third will be the timestamps of the first and the last message from that array.

If channel is NULL, then channel_group cannot be NULL and you will get history only for the channel group. It goes both ways: if channel_group is NULL, then channel cannot be NULL and you will get history only for the channel.

Also, if you select to include_token, then the JSON array you get will not be a simple array of gotten messages, but rather an array of JSON objects, having keys message with value the actual message, and timetoken with the time token of that particular message.

You can't get history if a transaction is in progress on the context.



===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context.
| channel | const char* | No | The string with the channel name to get message history for. This can't be a comma separated list of channels.
| channel_group | const char* | No | The string with the channel group name to get message history for. This can't be a comma separated list
| count | unsigned | Yes | Maximum number of messages to get. If there are less than this available on the channel, you'll get less, but you can't get more.
| include_token | bool | Yes | If true, include the time token for every gotten message
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | PNR_STARTED on success, an error otherwise
|======================


===== BASIC USAGE
```

unsigned count = 100; /* number of messages to retrieve */
pubnub_historyv2(ctx, “my_channel”, NULL, count, true);
pbresult = pubnub_await(ctx);
if (PNR_OK == pbresult) {
    for (;;) {
        msg = pubnub_get(ctx);
        if (NULL == msg) {
            break;
        }
        puts(msg);
    }
}

```
===== OTHER EXAMPLES


== pubnub_here_now

===== enum pubnub_res pubnub_here_now (pubnub_t *p, const char *channel, const char *channel_group)

===== DESCRIPTION
Get the currently present users on a channel and/or channel_group. This actually means "initiate a here_now transaction". It can be thought of as a query against the "presence database".

If transaction is successful, the response will be a available via pubnub_get() as one message, a JSON object. Following keys are always present:

* "status": the HTTP status of the operation (200 OK, 40x error, etc.)
* "message": the string/message describing the status ("OK"...)
* "service": should be "Presence"

If doing a query on a single channel, following keys are present:

* "uuids": an array of UUIDs of currently present users
* "occupancy": the number of currently present users in the channel

If doing a query on more channels, a key "payload" is present, which is a JSON object whose keys are:

* "channels": a JSON object with keys being the names of the channels and their values JSON objects with keys "uuids" and "occupancy" with the meaning the same as for query on a single channel
* "total_channels": the number of channels for which the presence is given (in "payload")
* "total_occupancy": total number of users present in all channels

If channel is NULL, then channel_group cannot be NULL and you will subscribe only to the channel group(s). It goes both ways:
if channel_group is NULL, then channel cannot be NULL and you will subscribe only to the channel(s).

You can't get list of currently present users if a transaction is in progress on the context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to Pubnub Client Context
| channel | const char * |  No | The string with the channel name (or comma-delimited list of channel names) to get presence info for.
| channel_group | const char * | No | The string with the channel name (or comma-delimited list of channel group names) to get presence info for.

|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | PNR_STARTED on success, an error otherwise
|======================

===== BASIC USAGE
```
pubnub_here_now(ctx, “my_channel”, NULL);
pbresult = pubnub_await(ctx);
if (PNR_OK == pbresult) {
    char const *json_response = pubnub_get(ctx);
}
```


===== OTHER EXAMPLES

== pubnub_global_here_now

===== enum pubnub_res pubnub_global_here_now (pubnub_t *p)

===== DESCRIPTION
Get the currently present users on all channel. This actually means "initiate a global here_now transaction". It can be thought of as a query against the "presence database".

If transaction is successful, the response will be the same as for "multi-channel" response for pubnub_here_now(), if we queried against all currently available channels.

You can't get list of currently present users if a transaction is in progress on the context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t * | Yes | Pointer to Pubnub Client Context. Can't be NULL>
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | PNR_STARTED on success, an error otherwise
|======================

===== BASIC USAGE
```
pubnub_global_here_now(ctx);
pbresult = pubnub_await(ctx);
if (PNR_OK == pbresult) {
    char const *json_response = pubnub_get(ctx);
}
```
===== OTHER EXAMPLES

== pubnub_where_now

===== enum pubnub_res pubnub_where_now (pubnub_t *p, const char *uuid)

===== DESCRIPTION
Get the currently present users on a channel and/or channel_group. This actually means "initiate a here_now transaction". It can be thought of as a query against the "presence database".

If transaction is successful, the response will be a available via pubnub_get() as one message, a JSON object with keys:

* "status": the HTTP status of the operation (200 OK, 40x error, etc.)
* "message": the string/message describing the status ("OK"...)
* "service": should be "Presence"
* "payload": JSON object with a key "channels" which is an array of channels this user is present in

You can't get channel presence for the user if a transaction is in progress on the context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to Pubnub Client Context
| uuid | const char* | No | The UUID of the user to get the channel presence. If NULL, the current UUID of the p context will be used.
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | PNR_STARTED on success, an error otherwise
|======================

===== BASIC USAGE
```
pubnub_where_now(ctx, “search_uuid”);
pbresult = pubnub_await(ctx);
if (PNR_OK == pbresult) {
    char const *json_response = pubnub_get(ctx);
}
```
===== OTHER EXAMPLES


== pubnub_set_state

===== enum pubnub_res pubnub_set_state (pubnub_t *p, char const *channel, char const *channel_group, const char *uuid, char const *state)

===== DESCRIPTION
Sets some state for the channel and/or for a user, identified by uuid. This actually means "initiate a set state transaction". It can be thought of as an update against the "presence database".

* "State" has to be a JSON object (IOW, several "key-value" pairs).

If transaction is successful, the response will be a available via pubnub_get() as one message, a JSON object with following keys:

* "status": the HTTP status of the operation (200 OK, 40x error, etc.)
* "message": the string/message describing the status ("OK"...)
* "service": should be "Presence"
* "payload" the state

This will set the same state to all channels identified by channel and channel_group.

If channel is NULL, then channel_group cannot be NULL and you will set state only to the channel group(s). It goes both ways: if channel_group is NULL, then channel cannot be NULL and you will set state only to the channel(s).

You can't set state of channels if a transaction is in progress on the context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to Pubnub Client Context
| channel | char const* | No | The string with the channel name (or comma-delimited list of channel names) to set state for.
| channel_group | char const* | No | The string with the channel name (or comma-delimited list of channel group names) to set state for.
| uuid | const char* | No | The UUID of the user for which to set state for. If NULL, the current UUID of the p context will be used.
| state | char const* | Yes  | Has to be a JSON object
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | PNR_STARTED on success, an error otherwise
|======================

===== BASIC USAGE
```
pubnub_set_state(ctx, "hello_world", NULL, NULL, NULL);
pbresult = pubnub_await(ctx);
if (PNR_OK == pbresult) {
    printf("Set success\n");
}
```

===== OTHER EXAMPLES


== pubnub_state_get

===== enum pubnub_res pubnub_state_get (pubnub_t *p, char const *channel, char const *channel_group, const char *uuid)

===== DESCRIPTION
Gets some state for the channel and/or for a user, identified by uuid. This actually means "initiate a get state transaction". It can be thought of as a query against the "presence database".

If transaction is successful, the response will be a available via pubnub_get() as one message, a JSON object with following keys:

* "status": the HTTP status of the operation (200 OK, 40x error, etc.)
* "message": the string/message describing the status ("OK"...)
* "service": should be "Presence"
* "payload": if querying against one channel the gotten state (a JSON object), otherwise a JSON object with the key "channels" whose value is a JSON object with keys the name of the channels and their respective values JSON objects of the gotten state

If channel is NULL, then channel_group cannot be NULL and you will get state only for the channel group(s). It goes both ways: if channel_group is NULL, then channel cannot be NULL and you will get state only for the channel(s).

You can't set state of channels if a transaction is in progress on the context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to Pubnub Client Context
| channel | char const* | | The string with the channel name (or comma-delimited list of channel names) to set state for.
| channel_group | char const* | | The string with the channel name (or comma-delimited list of channel group names) to set state for.
| uuid | const char* | | The UUID of the user for which to set state for. If NULL, the current UUID of the p context will be used.

|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | PNR_STARTED on success, an error otherwise
|======================

===== BASIC USAGE
```
pubnub_get_state(ctx, “my_channel”);
pbresult = pubnub_await(ctx);
if (PNR_OK == pbresult) {
    char const *json_response = pubnub_get(ctx);
}
```

===== OTHER EXAMPLES


== pubnub_remove_channel_group

===== enum pubnub_res pubnub_remove_channel_group (pubnub_t *p, char const *channel_group)

===== DESCRIPTION
Removes a channel_group and all its channels. This actually means "initiate a remove_channel_group transaction". It can be thought of as an update against the "channel group database".

If transaction is successful, the response will be a available via pubnub_get_channel() as one "channel", a JSON object with keys:

* "service": should be "channel-registry"
* "status": the HTTP status of the operation (200 OK, 40x error, etc.)
* "error": true on error, false on success
* "message": the string/message describing the status ("OK"...)

You can't remove a channel group if a transaction is in progress on the context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to Pubnub client context.
| channel_group | char const* | Yes | The channel group to remove.
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | PNR_STARTED on success, an error otherwise
|======================

===== BASIC USAGE
```
pubnub_remove_channel_group(ctx, “channel_group”);
pbresult = pubnub_await(ctx);
if (PNR_OK == pbresult) {
    printf("Channel group removed");
}
```

===== OTHER EXAMPLES



== pubnub_remove_channel_from_group

===== enum pubnub_res pubnub_remove_channel_from_group (pubnub_t *p, char const *channel, char const *channel_group)

===== DESCRIPTION
Removes a channel from the channel_group . This actually means "initiate a remove_channel_from_channel_group transaction". It can be thought of as an update against the "channel group database".

You can't remove the last channel from a channel group. To do that, remove the channel group itself.

If transaction is successful, the response will be a available via pubnub_get_channel() as one "channel", a JSON object with keys:

* "service": should be "channel-registry"
* "status": the HTTP status of the operation (200 OK, 40x error, etc.)
* "error": true on error, false on success
* "message": the string/message describing the status ("OK"...)

You can't remove a channel from a channel group if a transaction is in progress on the context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context
| channel | char const* | Yes | The channel to remove
| channel_group | char const* | Yes | The channel group to remove from

|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | PNR_STARTED on success, an error otherwise
|======================

===== BASIC USAGE
```
pubnub_remove_channel_from_group(ctx, "channel", “channel_group”);
pbresult = pubnub_await(ctx);
if (PNR_OK == pbresult) {
    printf("Channel removed from group");
}
```

===== OTHER EXAMPLES


== pubnub_add_channel_to_group

===== enum pubnub_res pubnub_add_channel_to_group (pubnub_t *p, char const *channel, char const *channel_group)

===== DESCRIPTION
Adds a channel to the channel_group . This actually means "initiate a add_channel_to_channel_group transaction". It can be thought of as an update against the "channel group database".

If the channel group doesn't exist, this implicitly adds (creates) it.

If transaction is successful, the response will be a available via pubnub_get_channel() as one "channel", a JSON object with keys:

* "service": should be "channel-registry"
* "status": the HTTP status of the operation (200 OK, 40x error, etc.)
* "error": true on error, false on success
* "message": the string/message describing the status ("OK"...)

You can't add a channel to a channel group if a transaction is in progress on the context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context
| channel | char const* | Yes | The channel to add
| channel_group | char const* | Yes | The channel group to add to

|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | #PNR_STARTED on success, an error otherwise
|======================

===== BASIC USAGE
```
pubnub_add_channel_to_group(ctx, "channel", “channel_group”);
pbresult = pubnub_await(ctx);
if (PNR_OK == pbresult) {
    printf("Channel added to group");
}
```

===== OTHER EXAMPLES


== pubnub_list_channel_group

===== enum pubnub_res pubnub_list_channel_group (pubnub_t *p, char const *channel_group)

===== DESCRIPTION
Lists all channels of a channel_group. This actually means "initiate a list_channel_group transaction". It can be thought of as a query against the "channel group database".

If transaction is successful, the response will be a available via pubnub_get_channel() as one "channel", a JSON object with keys:

* "service": should be "channel-registry"
* "status": the HTTP status of the operation (200 OK, 40x error, etc.)
* "error": true on error, false on success
* "payload": JSON object with keys "group" with value the string of the channel group name and "channels" with value a JSON * * array of strings with names of the channels that belong to the group

You can't remove a channel group if a transaction is in progress on the context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context
| channel_group | char const* | Yes | The channel group to list channels from
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | PNR_STARTED on success, an error otherwise
|======================

===== BASIC USAGE
```
pubnub_list_channel_group(ctx, “my_channel_group”);
pbresult = pubnub_await(ctx);
if (PNR_OK == pbresult) {
    char const *json_response = pubnub_get(ctx);
}
```

===== OTHER EXAMPLES


== pubnub_last_http_code

enum pubnub_res int pubnub_last_http_code(pubnub_t const *p)

===== DESCRIPTION
Returns the HTTP reply code of the last transaction in the p context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| int | HTTP reply code of the last transaction in the p context.
|======================

===== BASIC USAGE
```
pubnub_list_channel_group(ctx, “my_channel_group”);
pbresult = pubnub_await(ctx);
printf("HTTP Status Code %d\n", pubnub_last_http_code(ctx));
```

===== OTHER EXAMPLES

== pubnub_last_result

===== int pubnub_last_result (pubnub_t const *p)

===== DESCRIPTION
Returns the result of the last transaction in the p context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | result of the last transaction in the context.
|======================

===== BASIC USAGE
```
pubnub_list_channel_group(ctx, “my_channel_group”);
pbresult = pubnub_await(ctx);
printf("Last result %s\n", pubnub_res_2_string(pbresult));
```

===== OTHER EXAMPLES



== pubnub_last_publish_result

===== char const * 	pubnub_last_publish_result (pubnub_t const *p)

===== DESCRIPTION
Returns the string of the result of the last publish transaction, as returned from Pubnub. If the last transaction is not a publish, or there is some other error, it returns NULL. If the Publish was successfull, it will return "Sent", otherwise a description of the error.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| char const* | string of the result of the last publish transaction
|======================

===== BASIC USAGE
```
enum pubnub_res pbres;
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pbres = pubnub_publish(ctx, “hello_world”, “\”Hello from Pubnub C-core docs!\””);
if (pbresult != PNR_OK) {
    printf(“Failed to publish, error %d\n”, pbresult);
    pubnub_free(ctx);
    return -1;
}
printf("String result of last publish %s\n", pubnub_last_publish_result(ctx));
```

===== OTHER EXAMPLES




== pubnub_last_time_token

===== char const * 	pubnub_last_time_token (pubnub_t const *p)


===== DESCRIPTION
Returns the string of the last received time token on the p context. After pubnub_init() this should be "0".

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| char const* | string of the last received time token on the context
|======================

===== BASIC USAGE
```
printinf("Last time token %s\n", pubnub_last_time_token(ctx));
```

===== OTHER EXAMPLES

