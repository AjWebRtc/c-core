= PubNub Posix C API Reference

== pubnub_generate_uuid_v1_time

===== DESCRIPTION
This generates an UUID using the v1 algorithm (time-based). This
algorithm has some state, but, a lot of it is "node" identifier,
which is the MAC address of your Ethernet-ish network interface,
and most applications have one. If you don't have a MAC, you can
use some other identifier. If it has less than 6 octets, will use
what we have, but UUIDs will be of lesser quality. If you don't
have an identifier to use, than you can generate a random number.
If you don't have a random number generator, you can either give
up, or use the pubnub_time() to obtain a high-resolution time as a
pseudo-random number.

Besides that, it has the timestamp, which is a 100ns tick timer
that started at midnight 15 October 1582. If you have a clock,
just convert it to this format and you're good. Since it requires
64-bit integer support, and that is not always available, we are
accepting it as a 8-octet array. If you don't have a clock, but
have a timer, you can get time via pubnub_time() operation and
later add the timer ticks to it.

Last but not the least, there is the io_clock_seq, which is
generally used if the UUID generator gets the i_node and
i_timestamp itself and also keep the state, which we don't do,
for greater portability. We emulate this, by keeping a copy (in
volatile memory) of the last time-stamp and seeing if it changes
and assuming that node changes at first call, so we require the
user to gives a random number for the clock sequence on first
call. So, basically, on the first call, put a random value in @p
io_clock_seq, and later just re-use the same variable, this
function will update it as needed. If you don't have random number
generator, you can use any pseudo-random number source (say a
timer tick or some other event counter) - actually use as many as
you have and mix the values (the simplest option is just to XOR
the values you have, other is to make a message digest (MD5,
SHA-1) of all the values).

While rather complex to use, it is very portable and can be made
to work, with effort, on pretty much any platform, without the
need to obtain unique identifiers yourself (like you need to do
for v3 and v5).


===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| o_uuid | struct Pubnub_UUID* | Yes | The place to put the generated UUID to
| io_clock_seq | uint16_t* | Yes | Clock Sequence - initialize to a random value on first call, later just reuse
| i_timestamp | uint8_t const[8] | Yes | Count of 100- nanosecond intervals since 00:00:00.00, 15 October 1582 (the date of Gregorian reform to the Christian calendar). 
| i_node | uint8_t const[6] | Yes | A 6-octet "node" identity. Designed to be an IEEE 802 MAC address, but if you don't have it on your system, you can use something else.
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| int | OK (generated), otherwise: error, algorithm not available
|======================

===== BASIC USAGE
TO BE ADDED


===== OTHER EXAMPLES


== pubnub_generate_uuid_v3_name_md5

===== DESCRIPTION
The name based algorithms (this - v3 and the other - v5) don't
need any other state but the arguments they declare.
But, they do need a hash, in this case MD5. For various
reasons, a particular hash may not be available on
a particular platform.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| uuid | struct Pubnub_UUID* | Yes | The place to put the generated UUID to
| nsid | struct Pubnub_UUID* | Yes | The UUID of the namespace used. We provide a few examples.
| name | void* | Yes | Pointer to the data that defines the name you want to use for UUID generation
| namelen | unsigned | Yes | The length of the name data.
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| int | 0: OK (generated), otherwise: error, algorithm not available
|======================

===== BASIC USAGE
TO BE ADDED

===== OTHER EXAMPLES


== pubnub_generate_uuid_v4_random

===== DESCRIPTION
The nice property of this random-base algorithm is that it needs
no state what-so-ever. A not so nice property is that it needs a
random number generator of good quality, and you may not have
that on a particular platform.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| uuid | struct Pubnub_UUID* | Yes | The place to put the generated UUID to
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| int | 0: OK (generated), otherwise: error, random number generator not available
|======================

===== BASIC USAGE
TO BE ADDED

===== OTHER EXAMPLES


== pubnub_generate_uuid_v5_name_sha1

===== DESCRIPTION
The name based algorithms (this - v5 and the other - v3) don't
need any other state but the arguments they declare.
But, they do need a hash, in this case SHA-1. For various
reasons, a particular hash may not be available on
a particular platform.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| uuid | struct Pubnub_UUID* | Yes | The place to put the generated UUID to
| nsid | struct Pubnub_UUID* | Yes | The UUID of the namespace used. We provide a few examples
| name | void* | | Pointer to the data that defines the name you want to use for UUID generation
| namelen | unsigned | | The length of the name data
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| int | 0: OK (generated), otherwise: error, algorithm not available
|======================

===== BASIC USAGE
TO BE ADDED

===== OTHER EXAMPLES


== pubnub_uuid_to_string

===== DESCRIPTION
Returns UUID as a standard HEX-based representation

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| uuid | struct Pubnub_UUID const* | Yes | uuid to be converted to string
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| struct Pubnub_UUID_String | String representation of uuid
|======================

===== BASIC USAGE
TO BE ADDED

===== OTHER EXAMPLES



== pubnub_uuid_compare

===== DESCRIPTION
Compares two UUIDs (@p left and @p right) and returns:
- 0: equal
- <0: left < right
- >0: left > right
    
===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| left | struct Pubnub_UUID const* | Yes | uuid to be compared
| right | struct Pubnub_UUID const* | Yes | uuid to be compared
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| int | 0 if equal, <0: left < right, >0: left > right
|======================

===== BASIC USAGE
TO BE ADDED

===== OTHER EXAMPLES
