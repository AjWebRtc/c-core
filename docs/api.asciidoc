= PubNub Posix C API Reference

== pubnub_init

===== DESCRIPTION
Initialize a given pubnub context p to the publish_key and subscribe_key.
You can customize other parameters of the context by the configuration function calls below.

The publish_key and subscribe key are expected to be valid (ASCIIZ string) pointers throughout the use of context p,
that is, until either you call pubnub_done(), or the otherwise stop using it (like when the whole software/ firmware 
stops working). So, the contents of these keys are not copied to the Pubnub context p.

This should be called after TCP initialization.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
|p        |pubnub_t* | Yes | Pointer to the Context to initialize (use pubnub_get_ctx() to obtain it)
|publish_key  | char * | | Pointer to the string of the key to use when publishing messages
|subscribe_key  | char * | | Pointer to the string of the key to use when subscribing to messages

|======================

===== RETURNS
void

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
```
===== OTHER EXAMPLES

== pubnub_set_uuid

===== DESCRIPTION

Set the UUID identification of PubNub client context p to uuid. Pass NULL to unset.

[NOTE}
The uuid is expected to be valid (ASCIIZ string) pointers throughout the use of context p, that is, until either you call pubnub_done() on p, or the otherwise stop using it (like when the whole software/ firmware stops working). So, the contents of the uuid string is not copied to the Pubnub context p.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description 
| p | pubnub_t* | Yes | Pointer to pubnub context. 
| uuid | const char* | | Pointer to uuid string 
|======================

===== RETURNS
void

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_set_uuid(ctx, "my_uuid");
```
===== OTHER EXAMPLES


== pubnub_uuid_get 

===== DESCRIPTION

Get the UUID identification of PubNub client context p. After pubnub_init(), it will return NULL until you change it to non-NULL via pubnub_set_uuid().

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context.
|======================

===== RETURNS
char const*

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_set_uuid(ctx, "my_uuid");
printf("UUID is %s", pubnub_get_uuid(ctx));
```
===== OTHER EXAMPLES

== pubnub_set_auth

===== DESCRIPTION
Set the authentication information of PubNub client context p. Pass NULL to unset.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context
| auth | const char* | Yes | Pointer to auth string. NULL to unset
|======================

===== RETURNS
void

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_set_auth(ctx, "my_auth_key");
```
===== OTHER EXAMPLES


== pubnub_auth_get

===== DESCRIPTION
Returns the current authentication information for the context p. After pubnub_init(), it will return NULL until you change it to non-NULL via pubnub_set_auth().

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t const* | Yes | Pointer to pubnub client context
|======================

===== RETURNS
char const*

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_set_auth(ctx, "my_auth_key");
printf("Auth Key is %s", pubnub_get_auth(ctx));
```
===== OTHER EXAMPLES

== pubnub_cancel

===== DESCRIPTION
Cancel an ongoing API transaction. The outcome of the transaction in progress, if any, will be #PNR_CANCELLED.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to Pubnub Client Context.
|======================

===== RETURNS
void

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_publish(ctx, “hello_world”, “\”Hello from Pubnub C-core docs!\””);
pubnub_cancel(ctx);
```

===== OTHER EXAMPLES


== pubnub_publish

===== DESCRIPTION
Publish the message (in JSON format) on p channel, using the p context. This actually means "initiate a publish transaction".

You can't publish if a transaction is in progress in p context.

If transaction is not successful (PNR_PUBLISH_FAILED), you can get the string describing the reason for failure by calling pubnub_last_publish_result().

Keep in mind that the time token from the publish operation response is not parsed by the library, just relayed to the user. Only time-tokens from the subscribe operation are parsed by the library.

Also, for all error codes known at the time of this writing, the HTTP error will be set also, so the result of the Pubnub operation will not be PNR_OK (but you will still be able to get the result code and the description).

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub context. Can't be NULL
| channel | const char* | Yes | Pointer to string with the channel name (or comma-delimited list of channel names) to publish to.
| message | const char* | Yes | Pointer to string containing message to publish in JSON format. 
|======================

===== RETURNS
enum pubnub_res
#PNR_STARTED on success, an error otherwise

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_publish(ctx, “hello_world”, “\”Hello from Pubnub C-core docs!\””);
if (pbresult != PNR_OK) {
    printf(“Failed to publish, error %d\n”, pbresult);
    pubnub_free(ctx);
    return -1;
}
```

===== OTHER EXAMPLES

== pubnub_publishv2

===== DESCRIPTION
Publish the message (in JSON format) on p channel, using the p context, utilizing the v2 API. This actually means "initiate a publish transaction".

Basically, this is an extension to the pubnub_publish() (v1), with some additional options.

You can't publish if a transaction is in progress in p context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to Pubnub Client Context
| channel | const char* | Yes | Pointer to string with the channel name (or comma-delimited list of channel names) to publish to.
| message | const char* | Yes | Pointer to string containing message to publish in JSON format. 
| store_in_history | bool | Yes | If false, message will not be stored in history of the channel
| eat_after_reading | bool | yes | If true, message will not be stored for delayed or repeated retrieval or display
|======================

===== RETURNS
enum pubnub_res
#PNR_STARTED on success, an error otherwise

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_publishv2(ctx, “hello_world”, “\”Hello from Pubnub C-core docs!\””, true, true);
if (pbresult != PNR_OK) {
    printf(“Failed to publish, error %d\n”, pbresult);
    pubnub_free(ctx);
    return -1;
}
```
===== OTHER EXAMPLES

== pubnub_get

===== DESCRIPTION
Returns a pointer to an arrived message or other element of the response to an operation/transaction. Message(s) arrive on finish of a subscribe operation or history operation, while for some other operations this will give access to the whole response, or the next element of the response. That is documented in the function that starts the operation.

Subsequent call to this function will return the next message (if any). All messages are from the channel(s) the last operation was for.

NOTE:   Context doesn't keep track of the channel(s) you subscribed to. This is a memory saving design decision, as most users won't change the channel(s) they subscribe too.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to Pubnub Client Context
|======================

===== RETURNS
char const*
Pointer to message, NULL on error

===== BASIC USAGE
```
pubnub_subscribe(ctx, “hello_world”, NULL);
pbresult = pubnub_await(ctx);
if (pbresult != PNR_OK) {
    printf(“Failed to subscribe, error %d\n”, pbresult);
    pubnub_free(ctx);
    return -1;
}
else {
    char const *msg = pubnub_get(ctx);
    while (msg != NULL) {
        printf(“Got message: %s\n”, msg);
        msg = pubnub_get(ctx);
    }
}
pubnub_free(ctx);
```

===== OTHER EXAMPLES


== pubnub_get_channel

===== DESCRIPTION
Returns a pointer to an fetched subscribe operation/transaction's next channel. Each transaction may hold a list of channels, and this functions provides a way to read them. Subsequent call to this function will return the next channel (if any).

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| pb | pubnub_t* | Yes | Pointer to Pubnub Client Context. Can't be NULL.
|======================

===== RETURNS
char const*
Pointer to channel, NULL on error

===== BASIC USAGE
```
pubnub_subscribe(ctx, “hello_world”, NULL);
pbresult = pubnub_await(ctx);
if (pbresult != PNR_OK) {
    printf(“Failed to subscribe, error %d\n”, pbresult);
    pubnub_free(ctx);
    return -1;
}
else {
    char const *msg = pubnub_get(ctx);
    char const *channel = pubnub_get_channel(ctx);
    while (msg != NULL) {
        printf(“Got message: %s on channel %s\n”, msg, channel);
        msg = pubnub_get(ctx);
        channel = pubnub_get_channel(ctx);
    }
}
pubnub_free(ctx);
```
===== OTHER EXAMPLES

==

===== DESCRIPTION

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description

|======================

===== RETURNS

===== BASIC USAGE

===== OTHER EXAMPLES


==

===== DESCRIPTION

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description

|======================

===== RETURNS

===== BASIC USAGE

===== OTHER EXAMPLES
