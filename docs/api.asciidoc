= PubNub Posix C API Reference

== pubnub_init

===== DESCRIPTION
Initialize a given pubnub context p to the publish_key and subscribe_key.
You can customize other parameters of the context by the configuration function calls below.

The publish_key and subscribe key are expected to be valid (ASCIIZ string) pointers throughout the use of context p,
that is, until either you call pubnub_done(), or the otherwise stop using it (like when the whole software/ firmware 
stops working). So, the contents of these keys are not copied to the Pubnub context p.

This should be called after TCP initialization.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
|p        |pubnub_t* | Yes | Pointer to the Context to initialize (use pubnub_get_ctx() to obtain it)
|publish_key  | char * | | Pointer to the string of the key to use when publishing messages
|subscribe_key  | char * | | Pointer to the string of the key to use when subscribing to messages

|======================

===== RETURNS

[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| void |
|======================

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
```
===== OTHER EXAMPLES

== pubnub_set_uuid

===== DESCRIPTION

Set the UUID identification of PubNub client context p to uuid. Pass NULL to unset.

NOTE: The uuid is expected to be valid (ASCIIZ string) pointers throughout the use of context p, that is, until either you call pubnub_done() on p, or the otherwise stop using it (like when the whole software/ firmware stops working). So, the contents of the uuid string is not copied to the Pubnub context p.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description 
| p | pubnub_t* | Yes | Pointer to pubnub context. 
| uuid | const char* | | Pointer to uuid string 
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| void |
|======================

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_set_uuid(ctx, "my_uuid");
```
===== OTHER EXAMPLES


== pubnub_uuid_get 

===== DESCRIPTION

Get the UUID identification of PubNub client context p. After pubnub_init(), it will return NULL until you change it to non-NULL via pubnub_set_uuid().

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context.
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| char const* |
|======================

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_set_uuid(ctx, "my_uuid");
printf("UUID is %s", pubnub_get_uuid(ctx));
```
===== OTHER EXAMPLES

== pubnub_set_auth

===== DESCRIPTION
Set the authentication information of PubNub client context p. Pass NULL to unset.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context
| auth | const char* | Yes | Pointer to auth string. NULL to unset
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| void |
|======================

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_set_auth(ctx, "my_auth_key");
```
===== OTHER EXAMPLES


== pubnub_auth_get

===== DESCRIPTION
Returns the current authentication information for the context p. After pubnub_init(), it will return NULL until you change it to non-NULL via pubnub_set_auth().

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t const* | Yes | Pointer to pubnub client context
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| char const* |
|======================

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_set_auth(ctx, "my_auth_key");
printf("Auth Key is %s", pubnub_get_auth(ctx));
```
===== OTHER EXAMPLES

== pubnub_cancel

===== DESCRIPTION
Cancel an ongoing API transaction. The outcome of the transaction in progress, if any, will be #PNR_CANCELLED.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to Pubnub Client Context.
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| void |
|======================

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_publish(ctx, “hello_world”, “\”Hello from Pubnub C-core docs!\””);
pubnub_cancel(ctx);
```

===== OTHER EXAMPLES


== pubnub_publish

===== DESCRIPTION
Publish the message (in JSON format) on p channel, using the p context. This actually means "initiate a publish transaction".

You can't publish if a transaction is in progress in p context.

If transaction is not successful (PNR_PUBLISH_FAILED), you can get the string describing the reason for failure by calling pubnub_last_publish_result().

Keep in mind that the time token from the publish operation response is not parsed by the library, just relayed to the user. Only time-tokens from the subscribe operation are parsed by the library.

Also, for all error codes known at the time of this writing, the HTTP error will be set also, so the result of the Pubnub operation will not be PNR_OK (but you will still be able to get the result code and the description).

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub context. Can't be NULL
| channel | const char* | Yes | Pointer to string with the channel name (or comma-delimited list of channel names) to publish to.
| message | const char* | Yes | Pointer to string containing message to publish in JSON format. 
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | #PNR_STARTED on success, an error otherwise
|======================



===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_publish(ctx, “hello_world”, “\”Hello from Pubnub C-core docs!\””);
if (pbresult != PNR_OK) {
    printf(“Failed to publish, error %d\n”, pbresult);
    pubnub_free(ctx);
    return -1;
}
```

===== OTHER EXAMPLES

== pubnub_publishv2

===== DESCRIPTION
Publish the message (in JSON format) on p channel, using the p context, utilizing the v2 API. This actually means "initiate a publish transaction".

Basically, this is an extension to the pubnub_publish() (v1), with some additional options.

You can't publish if a transaction is in progress in p context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to Pubnub Client Context
| channel | const char* | Yes | Pointer to string with the channel name (or comma-delimited list of channel names) to publish to.
| message | const char* | Yes | Pointer to string containing message to publish in JSON format. 
| store_in_history | bool | Yes | If false, message will not be stored in history of the channel
| eat_after_reading | bool | yes | If true, message will not be stored for delayed or repeated retrieval or display
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | #PNR_STARTED on success, an error otherwise
|======================

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_publishv2(ctx, “hello_world”, “\”Hello from Pubnub C-core docs!\””, true, true);
if (pbresult != PNR_OK) {
    printf(“Failed to publish, error %d\n”, pbresult);
    pubnub_free(ctx);
    return -1;
}
```
===== OTHER EXAMPLES

== pubnub_get

===== DESCRIPTION
Returns a pointer to an arrived message or other element of the response to an operation/transaction. Message(s) arrive on finish of a subscribe operation or history operation, while for some other operations this will give access to the whole response, or the next element of the response. That is documented in the function that starts the operation.

Subsequent call to this function will return the next message (if any). All messages are from the channel(s) the last operation was for.

NOTE:   Context doesn't keep track of the channel(s) you subscribed to. This is a memory saving design decision, as most users won't change the channel(s) they subscribe too.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to Pubnub Client Context
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| char const* | Pointer to message. Can't be NULL.
|======================

===== BASIC USAGE
```
pubnub_subscribe(ctx, “hello_world”, NULL);
pbresult = pubnub_await(ctx);
if (pbresult != PNR_OK) {
    printf(“Failed to subscribe, error %d\n”, pbresult);
    pubnub_free(ctx);
    return -1;
}
else {
    char const *msg = pubnub_get(ctx);
    while (msg != NULL) {
        printf(“Got message: %s\n”, msg);
        msg = pubnub_get(ctx);
    }
}
pubnub_free(ctx);
```

===== OTHER EXAMPLES


== pubnub_get_channel

===== DESCRIPTION
Returns a pointer to an fetched subscribe operation/transaction's next channel. Each transaction may hold a list of channels, and this functions provides a way to read them. Subsequent call to this function will return the next channel (if any).

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| pb | pubnub_t* | Yes | Pointer to Pubnub Client Context. Can't be NULL.
|======================

===== RETURNS
char const*
Pointer to channel, NULL on error

===== BASIC USAGE
```
pubnub_subscribe(ctx, “hello_world”, NULL);
pbresult = pubnub_await(ctx);
if (pbresult != PNR_OK) {
    printf(“Failed to subscribe, error %d\n”, pbresult);
    pubnub_free(ctx);
    return -1;
}
else {
    char const *msg = pubnub_get(ctx);
    char const *channel = pubnub_get_channel(ctx);
    while (msg != NULL) {
        printf(“Got message: %s on channel %s\n”, msg, channel);
        msg = pubnub_get(ctx);
        channel = pubnub_get_channel(ctx);
    }
}
pubnub_free(ctx);
```
===== OTHER EXAMPLES

== pubnub_subscribe

===== DESCRIPTION
Subscribe to channel and/or channel_group. This actually means "initiate a subscribe operation/transaction". The outcome is sent to the process that starts the transaction via process event pubnub_publish_event, which is a good place to start reading the fetched message(s), via pubnub_get().

Messages published on channel and/or channel_group since the last subscribe transaction will be fetched.

The channel and channel_group strings may contain multiple comma-separated channel (channel group) names, so only one call is needed to fetch messages from multiple channels (channel groups).

If channel is NULL, then channel_group cannot be NULL and you will subscribe only to the channel group(s). It goes both ways: if channel_group is NULL, then channel cannot be NULL and you will subscribe only to the channel(s).

You can't subscribe if a transaction is in progress on the context.

Also, you can't subscribe if there are unread messages in the context (you read messages with pubnub_get()).

NOTE:   Some of the subscribed messages may be lost when calling publish() after a subscribe() on the same context or subscribe() on different channels in turn on the same context. But typically, you will want two separate contexts for publish and subscribe anyway. If you are changing the set of channels you subscribe to, you should first call pubnub_leave() on the old set.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to Pubnub client context. Can't be NULL.
| channel | const char* | No | The string with the channel name (or comma-delimited list of channel names) to subscribe to.
| channel_group | const char* | No | The string with the channel group name (or comma-delimited list of channel group names) to subscribe to.

|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | #PNR_STARTED on success, an error otherwise
|======================

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_subscribe(ctx, “hello_world”, NULL);
pbresult = pubnub_await(ctx);
if (pbresult != PNR_OK) {
    printf(“Failed to subscribe, error %d\n”, pbresult);
    pubnub_free(ctx);
    return -1;
}
else {
    char const *msg = pubnub_get(ctx);
    char const *channel = pubnub_get_channel(ctx);
    while (msg != NULL) {
        printf(“Got message: %s on channel %s\n”, msg, channel);
        msg = pubnub_get(ctx);
        channel = pubnub_get_channel(ctx);
    }
}
pubnub_free(ctx);
```
===== OTHER EXAMPLES

== pubnub_leave

===== DESCRIPTION
Leave the channel. This actually means "initiate a leave transaction". You should leave channel(s) when you want to subscribe to another in the same context to avoid loosing messages. Also, it is useful for tracking presence.

You can't leave if a transaction is in progress on the context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to Pubnub client context. Can't be NULL.
| channel | const char* | No | The string with the channel name (or comma-delimited list of channel names) to leave from.
| channel_group | const char * | No | The string with the channel group name (or comma-delimited list of channel group names) to leave from.
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | #PNR_STARTED on success, an error otherwise
|======================

===== BASIC USAGE
```
pubnub_t *ctx = pubnub_alloc();
if (NULL == ctx) {
    puts(“Couldn’t allocate a Pubnub context”);
    return -1;
}
pubnub_init(ctx, “demo”, “demo”);
pubnub_subscribe(ctx, “hello_world”, NULL);
pbresult = pubnub_await(ctx);
if (pbresult != PNR_OK) {
    printf(“Failed to subscribe, error %d\n”, pbresult);
    pubnub_free(ctx);
    return -1;
}
else {
    char const *msg = pubnub_get(ctx);
    char const *channel = pubnub_get_channel(ctx);
    while (msg != NULL) {
        printf(“Got message: %s on channel %s\n”, msg, channel);
        msg = pubnub_get(ctx);
        channel = pubnub_get_channel(ctx);
    }
}
pubnub_leave(ctx, "hello_world", NULL);
pbresult = pubnub_await(ctx);
if (PNR_OK == pbresult) {
    printf("Leave successful\n");
}
pubnub_free(ctx);
```

===== OTHER EXAMPLES


== pubnub_time

===== DESCRIPTION
Get the current Pubnub time token . This actually means "initiate a time transaction". Since time token is in the response to most Pubnub REST API calls, this is reserved mostly when you want to get a high-quality seed for a random number generator, or some such thing.

If transaction is successful, the gotten time will be the only message you can get with pubnub_get(). It will be a (large) JSON integer.

You can't get time if a transaction is in progress on the context.

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | #PNR_STARTED on success, an error otherwise
|======================
===== BASIC USAGE
```
pubnub_time(ctx);
pbresult = pubnub_await(ctx);
if (PNR_OK == pbresult) {
    char const *gotten_time = pubnub_get();
}

```

===== OTHER EXAMPLES





== pubnub_history

===== DESCRIPTION
Get the message history for the channel and/or channel_group. This actually means "initiate a history transaction".

If transaction is successful, the gotten messages will be available via the pubnub_get().

If channel is NULL, then channel_group cannot be NULL and you will get history only for the channel group. It goes both ways: if channel_group is NULL, then channel cannot be NULL and you will get history only for the channel.

You can't get history if a transaction is in progress on the context.
===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context.
| channel | const char* | | The string with the channel name to get message history for. This can't be a comma separated list of channels.
| channel_group | const char* | | The string with the channel group name to get message history for. This can't be a comma separated list
| count | unsigned | | Maximum number of messages to get. If there are less than this available on the channel, you'll get less, but you can't get more.
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | #PNR_STARTED on success, an error otherwise
|======================

===== BASIC USAGE
```

unsigned count = 100; /* number of messages to retrieve */
pubnub_history(ctx, “my_channel”, NULL, count);
pbresult = pubnub_await(ctx);
if (PNR_OK == pbresult) {
    char const *json_messages = pubnub_get(ctx);
    char const *first_timetoken = pubnub_get(ctx);
    char const *last_timetoken = pubnub_get(ctx);
}

```

===== OTHER EXAMPLES


== pubnub_historyv2

===== DESCRIPTION
Get the message history for the channel and/or channel_group using the v2 API. This actually means "initiate a history transaction/operation".

If transaction is successful, the gotten messages will be available via the pubnub_get(), but in a different way then pubnub_history(). In our case, pubnub_get() will give you exactly three messages (or, rather, elements). The first will be a JSON array of gotten messages, and the second and third will be the timestamps of the first and the last message from that array.

If channel is NULL, then channel_group cannot be NULL and you will get history only for the channel group. It goes both ways: if channel_group is NULL, then channel cannot be NULL and you will get history only for the channel.

Also, if you select to include_token, then the JSON array you get will not be a simple array of gotten messages, but rather an array of JSON objects, having keys message with value the actual message, and timetoken with the time token of that particular message.

You can't get history if a transaction is in progress on the context.



===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description
| p | pubnub_t* | Yes | Pointer to pubnub client context.
| channel | const char* | | The string with the channel name to get message history for. This can't be a comma separated list of channels.
| channel_group | const char* | | The string with the channel group name to get message history for. This can't be a comma separated list
| count | unsigned | | Maximum number of messages to get. If there are less than this available on the channel, you'll get less, but you can't get more.
| include_token | bool | | If true, include the time token for every gotten message
|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
| enum pubnub_res | #PNR_STARTED on success, an error otherwise
|======================


===== BASIC USAGE
```

unsigned count = 100; /* number of messages to retrieve */
pubnub_history(ctx, “my_channel”, NULL, count, true);
pbresult = pubnub_await(ctx);
if (PNR_OK == pbresult) {
    char const *json_messages = pubnub_get(ctx);
    char const *first_timetoken = pubnub_get(ctx);
    char const *last_timetoken = pubnub_get(ctx);
}

```
===== OTHER EXAMPLES


==

===== DESCRIPTION

===== METHODS

[width="40%",frame="topbot",options="header,footer"]
|======================
|Parameter | Type | Required | Description

|======================

===== RETURNS
[width="40%",frame="topbot",options="header,footer"]
|======================
| Type | Description
|======================

===== BASIC USAGE

===== OTHER EXAMPLES
