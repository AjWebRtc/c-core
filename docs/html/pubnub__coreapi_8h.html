<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Pubnub C SDK: core/pubnub_coreapi.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Pubnub C SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4270bfced15e0e73154b13468c7c9ad9.html">core</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pubnub_coreapi.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;pubnub_res.h&quot;</code><br/>
<code>#include &lt;stdbool.h&gt;</code><br/>
</div>
<p><a href="pubnub__coreapi_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a80cf98d90a11fab90abb8d57b046773c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a80cf98d90a11fab90abb8d57b046773c">PUBNUB_PRESENCE_SUFFIX</a>&#160;&#160;&#160;&quot;-pnpres&quot;</td></tr>
<tr class="separator:a80cf98d90a11fab90abb8d57b046773c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afaf02e571ac3551810b876ee151b5fc6"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structpubnub.html">pubnub</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#afaf02e571ac3551810b876ee151b5fc6">pubnub_t</a></td></tr>
<tr class="separator:afaf02e571ac3551810b876ee151b5fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af3efadf99ac4b832949265a675ec87b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#af3efadf99ac4b832949265a675ec87b0">pubnub_init</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p, const char *publish_key, const char *subscribe_key)</td></tr>
<tr class="separator:af3efadf99ac4b832949265a675ec87b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561f8188e2aa23b44e5b0038a82a4198"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a561f8188e2aa23b44e5b0038a82a4198">pubnub_set_uuid</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p, const char *uuid)</td></tr>
<tr class="separator:a561f8188e2aa23b44e5b0038a82a4198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca62c2a7f676cd084f335f983b6f1eb"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a1ca62c2a7f676cd084f335f983b6f1eb">pubnub_uuid_get</a> (<a class="el" href="structpubnub.html">pubnub_t</a> const *p)</td></tr>
<tr class="separator:a1ca62c2a7f676cd084f335f983b6f1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2289ad90d4d24a66f3407fb191e75281"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a2289ad90d4d24a66f3407fb191e75281">pubnub_set_auth</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p, const char *auth)</td></tr>
<tr class="separator:a2289ad90d4d24a66f3407fb191e75281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea851fb09fcfcf5d024c5e3ab1bae10d"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#aea851fb09fcfcf5d024c5e3ab1bae10d">pubnub_auth_get</a> (<a class="el" href="structpubnub.html">pubnub_t</a> const *p)</td></tr>
<tr class="separator:aea851fb09fcfcf5d024c5e3ab1bae10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285de94b69585fc83a1c3742035528f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a285de94b69585fc83a1c3742035528f7">pubnub_cancel</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p)</td></tr>
<tr class="separator:a285de94b69585fc83a1c3742035528f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af043957f0989781596c695b123f9686e"><td class="memItemLeft" align="right" valign="top">enum pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#af043957f0989781596c695b123f9686e">pubnub_publish</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p, const char *channel, const char *message)</td></tr>
<tr class="separator:af043957f0989781596c695b123f9686e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6ec570028527de1869df05d67a347f"><td class="memItemLeft" align="right" valign="top">enum pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#aef6ec570028527de1869df05d67a347f">pubnub_publishv2</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p, const char *channel, const char *message, bool store_in_history, bool eat_after_reading)</td></tr>
<tr class="separator:aef6ec570028527de1869df05d67a347f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d4b0fa460d97a1e256e44e60df2447"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#ab6d4b0fa460d97a1e256e44e60df2447">pubnub_get</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p)</td></tr>
<tr class="separator:ab6d4b0fa460d97a1e256e44e60df2447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08834b5041b308e7bc5747053c1020ed"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a08834b5041b308e7bc5747053c1020ed">pubnub_get_channel</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *pb)</td></tr>
<tr class="separator:a08834b5041b308e7bc5747053c1020ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c044b475d6902883e5ca41a1deabc4"><td class="memItemLeft" align="right" valign="top">enum pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a54c044b475d6902883e5ca41a1deabc4">pubnub_subscribe</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p, const char *channel, const char *channel_group)</td></tr>
<tr class="separator:a54c044b475d6902883e5ca41a1deabc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327aa6bbf7efac398dc453d31ba8097d"><td class="memItemLeft" align="right" valign="top">enum pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a327aa6bbf7efac398dc453d31ba8097d">pubnub_leave</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p, const char *channel, const char *channel_group)</td></tr>
<tr class="separator:a327aa6bbf7efac398dc453d31ba8097d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748bcf6a8df43e443100db9a9e6fe759"><td class="memItemLeft" align="right" valign="top">enum pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a748bcf6a8df43e443100db9a9e6fe759">pubnub_time</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p)</td></tr>
<tr class="separator:a748bcf6a8df43e443100db9a9e6fe759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf3862e98a8b449b143ad6b820bf1dd"><td class="memItemLeft" align="right" valign="top">enum pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#aebf3862e98a8b449b143ad6b820bf1dd">pubnub_history</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p, const char *channel, const char *channel_group, unsigned count)</td></tr>
<tr class="separator:aebf3862e98a8b449b143ad6b820bf1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb12ce1eaa8c7de06c17727bf034cd1"><td class="memItemLeft" align="right" valign="top">enum pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a6bb12ce1eaa8c7de06c17727bf034cd1">pubnub_historyv2</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p, const char *channel, const char *channel_group, unsigned count, bool include_token)</td></tr>
<tr class="separator:a6bb12ce1eaa8c7de06c17727bf034cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e882ea2d4828c8ebcf5ac7418c1572"><td class="memItemLeft" align="right" valign="top">enum pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a82e882ea2d4828c8ebcf5ac7418c1572">pubnub_here_now</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p, const char *channel, const char *channel_group)</td></tr>
<tr class="separator:a82e882ea2d4828c8ebcf5ac7418c1572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1df681eec8ac7697124d5179c8c240"><td class="memItemLeft" align="right" valign="top">enum pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a9e1df681eec8ac7697124d5179c8c240">pubnub_global_here_now</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p)</td></tr>
<tr class="separator:a9e1df681eec8ac7697124d5179c8c240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4086aeedb45d944d4b68ab3e0407e0f7"><td class="memItemLeft" align="right" valign="top">enum pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a4086aeedb45d944d4b68ab3e0407e0f7">pubnub_where_now</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p, const char *uuid)</td></tr>
<tr class="separator:a4086aeedb45d944d4b68ab3e0407e0f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1e29aa8c82763709a5e7e53de35144"><td class="memItemLeft" align="right" valign="top">enum pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#afc1e29aa8c82763709a5e7e53de35144">pubnub_set_state</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p, char const *channel, char const *channel_group, const char *uuid, char const *state)</td></tr>
<tr class="separator:afc1e29aa8c82763709a5e7e53de35144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69951cee4056d416b531dcf0f03c5b42"><td class="memItemLeft" align="right" valign="top">enum pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a69951cee4056d416b531dcf0f03c5b42">pubnub_state_get</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p, char const *channel, char const *channel_group, const char *uuid)</td></tr>
<tr class="separator:a69951cee4056d416b531dcf0f03c5b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d5ec4e620b8a9eea719445dbe6bd93"><td class="memItemLeft" align="right" valign="top">enum pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a42d5ec4e620b8a9eea719445dbe6bd93">pubnub_remove_channel_group</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p, char const *channel_group)</td></tr>
<tr class="separator:a42d5ec4e620b8a9eea719445dbe6bd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4e32da7ba33152ed4addce7b6a54c5"><td class="memItemLeft" align="right" valign="top">enum pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a0b4e32da7ba33152ed4addce7b6a54c5">pubnub_remove_channel_from_group</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p, char const *channel, char const *channel_group)</td></tr>
<tr class="separator:a0b4e32da7ba33152ed4addce7b6a54c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4358380d59dc7b3bffb12ad45f0204"><td class="memItemLeft" align="right" valign="top">enum pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#aad4358380d59dc7b3bffb12ad45f0204">pubnub_add_channel_to_group</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p, char const *channel, char const *channel_group)</td></tr>
<tr class="separator:aad4358380d59dc7b3bffb12ad45f0204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ce31971f4afb40ee00ea34130923da"><td class="memItemLeft" align="right" valign="top">enum pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#ac1ce31971f4afb40ee00ea34130923da">pubnub_list_channel_group</a> (<a class="el" href="structpubnub.html">pubnub_t</a> *p, char const *channel_group)</td></tr>
<tr class="separator:ac1ce31971f4afb40ee00ea34130923da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cea75959cd319da41900771686f4956"><td class="memItemLeft" align="right" valign="top">enum pubnub_res&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a5cea75959cd319da41900771686f4956">pubnub_last_result</a> (<a class="el" href="structpubnub.html">pubnub_t</a> const *p)</td></tr>
<tr class="separator:a5cea75959cd319da41900771686f4956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66dc0f940def45e87ec92d63539bdab1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a66dc0f940def45e87ec92d63539bdab1">pubnub_last_http_code</a> (<a class="el" href="structpubnub.html">pubnub_t</a> const *p)</td></tr>
<tr class="separator:a66dc0f940def45e87ec92d63539bdab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d7c7c38cd91b552df479ba21155c5c"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#a60d7c7c38cd91b552df479ba21155c5c">pubnub_last_publish_result</a> (<a class="el" href="structpubnub.html">pubnub_t</a> const *p)</td></tr>
<tr class="separator:a60d7c7c38cd91b552df479ba21155c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb826ed7d4b07795e799e9d7180e8aa2"><td class="memItemLeft" align="right" valign="top">char const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pubnub__coreapi_8h.html#aeb826ed7d4b07795e799e9d7180e8aa2">pubnub_last_time_token</a> (<a class="el" href="structpubnub.html">pubnub_t</a> const *p)</td></tr>
<tr class="separator:aeb826ed7d4b07795e799e9d7180e8aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the "Core" API of the Pubnub client library. It has the functions that are present in all variants and platforms and have the same interface in all of them. For the most part, they have the same implementation in all of them, too. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a80cf98d90a11fab90abb8d57b046773c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PUBNUB_PRESENCE_SUFFIX&#160;&#160;&#160;&quot;-pnpres&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append this to a name of the channel to form the name of its "presence" channel. A "presence" channel is a pseudo-channel on which notifications of presence changes of a channel are announced (sent by the Pubnub network). These notifications are JSON objects with the following keys:</p>
<ul>
<li>"action": the event that happened, can be "leave", "join", "timeout", "state-change"</li>
<li>"timestamp": the timestamp of the moment the event happened</li>
<li>"uuid": ID of the user that the event pertains to</li>
<li>"occupancy": current number of present users in the channel</li>
</ul>
<p>There is no special support for these (pseudo) channels in our Pubnub client. If you wish to receive presence events, simply append this suffix to the name of the channel and subscribe to that "combined" name. For example, to receive presence events on channel "my_channel", subscribe to "my_channel-pnpres".</p>
<p>Actually, you can subscribe to both a "regular" channel and a "presence" channel at the same time, and you'll receive both the presence events (on the "presence channel") and the published messages (on the "regular" channel). </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="afaf02e571ac3551810b876ee151b5fc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structpubnub.html">pubnub</a> <a class="el" href="structpubnub.html">pubnub_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A pubnub context. An opaque data structure that holds all the data needed for a context. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aad4358380d59dc7b3bffb12ad45f0204"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum pubnub_res pubnub_add_channel_to_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>channel_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a <code>channel</code> to the <code>channel_group</code> . This actually means "initiate a add_channel_to_channel_group transaction". It can be thought of as an update against the "channel group database".</p>
<p>If the channel group doesn't exist, this implicitly adds (creates) it.</p>
<p>If transaction is successful, the response will be a available via <a class="el" href="pubnub__coreapi_8h.html#a08834b5041b308e7bc5747053c1020ed">pubnub_get_channel()</a> as one "channel", a JSON object with keys:</p>
<ul>
<li>"service": should be "channel-registry"</li>
<li>"status": the HTTP status of the operation (200 OK, 40x error, etc.)</li>
<li>"error": true on error, false on success</li>
<li>"message": the string/message describing the status ("OK"...)</li>
</ul>
<p>You can't add a channel to a channel group if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The Pubnub context. Can't be NULL. </td></tr>
    <tr><td class="paramname">channel_group</td><td>The channel to add </td></tr>
    <tr><td class="paramname">channel_group</td><td>The channel group to add to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="aea851fb09fcfcf5d024c5e3ab1bae10d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const* pubnub_auth_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> const *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current authentication information for the context <code>p</code>. After <a class="el" href="pubnub__coreapi_8h.html#af3efadf99ac4b832949265a675ec87b0">pubnub_init()</a>, it will return <code>NULL</code> until you change it to non-<code>NULL</code> via <a class="el" href="pubnub__coreapi_8h.html#a2289ad90d4d24a66f3407fb191e75281">pubnub_set_auth()</a>. </p>

</div>
</div>
<a class="anchor" id="a285de94b69585fc83a1c3742035528f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pubnub_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancel an ongoing API transaction. The outcome of the transaction in progress, if any, will be #PNR_CANCELLED. </p>

</div>
</div>
<a class="anchor" id="ab6d4b0fa460d97a1e256e44e60df2447"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const* pubnub_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to an arrived message or other element of the response to an operation/transaction. Message(s) arrive on finish of a subscribe operation or history operation, while for some other operations this will give access to the whole response, or the next element of the response. That is documented in the function that starts the operation.</p>
<p>Subsequent call to this function will return the next message (if any). All messages are from the channel(s) the last operation was for.</p>
<dl class="section note"><dt>Note</dt><dd>Context doesn't keep track of the channel(s) you subscribed to. This is a memory saving design decision, as most users won't change the channel(s) they subscribe too.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The Pubnub context. Can't be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the message, NULL on error </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="pubnub__coreapi_8h.html#a54c044b475d6902883e5ca41a1deabc4">pubnub_subscribe</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a08834b5041b308e7bc5747053c1020ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const* pubnub_get_channel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>pb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to an fetched subscribe operation/transaction's next channel. Each transaction may hold a list of channels, and this functions provides a way to read them. Subsequent call to this function will return the next channel (if any).</p>
<dl class="section note"><dt>Note</dt><dd>You don't have to read all (or any) of the channels before you start a new transaction.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pb</td><td>The Pubnub context. Can't be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the channel, NULL on error </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="pubnub__coreapi_8h.html#a54c044b475d6902883e5ca41a1deabc4">pubnub_subscribe</a> </dd>
<dd>
<a class="el" href="pubnub__coreapi_8h.html#ab6d4b0fa460d97a1e256e44e60df2447">pubnub_get</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9e1df681eec8ac7697124d5179c8c240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum pubnub_res pubnub_global_here_now </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the currently present users on all channel. This actually means "initiate a global here_now transaction". It can be thought of as a query against the "presence database".</p>
<p>If transaction is successful, the response will be the same as for "multi-channel" response for <a class="el" href="pubnub__coreapi_8h.html#a82e882ea2d4828c8ebcf5ac7418c1572">pubnub_here_now()</a>, if we queried against all currently available channels.</p>
<p>You can't get list of currently present users if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The Pubnub context. Can't be NULL. </td></tr>
    <tr><td class="paramname">channel</td><td>The string with the channel name (or comma-delimited list of channel names) to get presence info for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a82e882ea2d4828c8ebcf5ac7418c1572"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum pubnub_res pubnub_here_now </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the currently present users on a <code>channel</code> and/or <code>channel_group</code>. This actually means "initiate a here_now
transaction". It can be thought of as a query against the "presence database".</p>
<p>If transaction is successful, the response will be a available via <a class="el" href="pubnub__coreapi_8h.html#ab6d4b0fa460d97a1e256e44e60df2447">pubnub_get()</a> as one message, a JSON object. Following keys are always present:</p>
<ul>
<li>"status": the HTTP status of the operation (200 OK, 40x error, etc.)</li>
<li>"message": the string/message describing the status ("OK"...)</li>
<li>"service": should be "Presence"</li>
</ul>
<p>If doing a query on a single channel, following keys are present:</p>
<ul>
<li>"uuids": an array of UUIDs of currently present users</li>
<li>"occupancy": the number of currently present users in the channel</li>
</ul>
<p>If doing a query on more channels, a key "payload" is present, which is a JSON object whose keys are:</p>
<ul>
<li>"channels": a JSON object with keys being the names of the channels and their values JSON objects with keys "uuids" and "occupancy" with the meaning the same as for query on a single channel</li>
<li>"total_channels": the number of channels for which the presence is given (in "payload")</li>
<li>"total_occupancy": total number of users present in all channels</li>
</ul>
<p>If <code>channel</code> is NULL, then <code>channel_group</code> cannot be NULL and you will subscribe only to the channel group(s). It goes both ways: if <code>channel_group</code> is NULL, then <code>channel</code> cannot be NULL and you will subscribe only to the channel(s).</p>
<p>You can't get list of currently present users if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The Pubnub context. Can't be NULL. </td></tr>
    <tr><td class="paramname">channel</td><td>The string with the channel name (or comma-delimited list of channel names) to get presence info for. </td></tr>
    <tr><td class="paramname">channel_group</td><td>The string with the channel name (or comma-delimited list of channel group names) to get presence info for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="aebf3862e98a8b449b143ad6b820bf1dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum pubnub_res pubnub_history </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the message history for the <code>channel</code> and/or <code>channel_group</code>. This actually means "initiate a history
transaction".</p>
<p>If transaction is successful, the gotten messages will be available via the <a class="el" href="pubnub__coreapi_8h.html#ab6d4b0fa460d97a1e256e44e60df2447">pubnub_get()</a>.</p>
<p>If <code>channel</code> is NULL, then <code>channel_group</code> cannot be NULL and you will get history only for the channel group. It goes both ways: if <code>channel_group</code> is NULL, then <code>channel</code> cannot be NULL and you will get history only for the channel.</p>
<p>You can't get history if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The Pubnub context. Can't be NULL. </td></tr>
    <tr><td class="paramname">channel</td><td>The string with the channel name to get message history for. This <em>can't</em> be a comma separated list of channels. </td></tr>
    <tr><td class="paramname">channel_group</td><td>The string with the channel group name to get message history for. This <em>can't</em> be a comma separated list </td></tr>
    <tr><td class="paramname">count</td><td>Maximum number of messages to get. If there are less than this available on the <code>channel</code>, you'll get less, but you can't get more.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a6bb12ce1eaa8c7de06c17727bf034cd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum pubnub_res pubnub_historyv2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the message history for the <code>channel</code> and/or <code>channel_group</code> using the v2 API. This actually means "initiate a history
transaction/operation".</p>
<p>If transaction is successful, the gotten messages will be available via the <a class="el" href="pubnub__coreapi_8h.html#ab6d4b0fa460d97a1e256e44e60df2447">pubnub_get()</a>, but in a different way then <a class="el" href="pubnub__coreapi_8h.html#aebf3862e98a8b449b143ad6b820bf1dd">pubnub_history()</a>. In our case, <a class="el" href="pubnub__coreapi_8h.html#ab6d4b0fa460d97a1e256e44e60df2447">pubnub_get()</a> will give you exactly three messages (or, rather, elements). The first will be a JSON array of gotten messages, and the second and third will be the timestamps of the first and the last message from that array.</p>
<p>If <code>channel</code> is NULL, then <code>channel_group</code> cannot be NULL and you will get history only for the channel group. It goes both ways: if <code>channel_group</code> is NULL, then <code>channel</code> cannot be NULL and you will get history only for the channel.</p>
<p>Also, if you select to <code>include_token</code>, then the JSON array you get will not be a simple array of gotten messages, but rather an array of JSON objects, having keys <code>message</code> with value the actual message, and <code>timetoken</code> with the time token of that particular message.</p>
<p>You can't get history if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The Pubnub context. Can't be NULL. </td></tr>
    <tr><td class="paramname">channel</td><td>The string with the channel name to get message history for. This <em>can't</em> be a comma separated list of channels. </td></tr>
    <tr><td class="paramname">channel_group</td><td>The string with the channel group name to get message history for. This <em>can't</em> be a comma separated list </td></tr>
    <tr><td class="paramname">count</td><td>Maximum number of messages to get. If there are less than this available on the <code>channel</code>, you'll get less, but you can't get more. </td></tr>
    <tr><td class="paramname">include_token</td><td>If true, include the time token for every gotten message</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="af3efadf99ac4b832949265a675ec87b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pubnub_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>publish_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>subscribe_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a given pubnub context <code>p</code> to the <code>publish_key</code> and <code>subscribe_key</code>. You can customize other parameters of the context by the configuration function calls below.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>publish_key</code> and <code>subscribe</code> key are expected to be valid (ASCIIZ string) pointers throughout the use of context <code>p</code>, that is, until either you call pubnub_done(), or the otherwise stop using it (like when the whole software/ firmware stops working). So, the contents of these keys are not copied to the Pubnub context <code>p</code>.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Call this after TCP initialization. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The Context to initialize (use pubnub_get_ctx() to obtain it) </td></tr>
    <tr><td class="paramname">publish_key</td><td>The string of the key to use when publishing messages </td></tr>
    <tr><td class="paramname">subscribe_key</td><td>The string of the key to use when subscribing to messages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66dc0f940def45e87ec92d63539bdab1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pubnub_last_http_code </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> const *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the HTTP reply code of the last transaction in the <code>p</code> context. </p>

</div>
</div>
<a class="anchor" id="a60d7c7c38cd91b552df479ba21155c5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const* pubnub_last_publish_result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> const *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the string of the result of the last <code>publish</code> transaction, as returned from Pubnub. If the last transaction is not a publish, or there is some other error, it returns NULL. If the Publish was successfull, it will return "Sent", otherwise a description of the error. </p>

</div>
</div>
<a class="anchor" id="a5cea75959cd319da41900771686f4956"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum pubnub_res pubnub_last_result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> const *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the result of the last transaction in the <code>p</code> context. </p>

</div>
</div>
<a class="anchor" id="aeb826ed7d4b07795e799e9d7180e8aa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const* pubnub_last_time_token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> const *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the string of the last received time token on the <code>p</code> context. After <a class="el" href="pubnub__coreapi_8h.html#af3efadf99ac4b832949265a675ec87b0">pubnub_init()</a> this should be "0". </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pubnub context to get the last received time token from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A read only string of the last received time token </dd></dl>

</div>
</div>
<a class="anchor" id="a327aa6bbf7efac398dc453d31ba8097d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum pubnub_res pubnub_leave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Leave the <code>channel</code>. This actually means "initiate a leave
transaction". You should leave channel(s) when you want to subscribe to another in the same context to avoid loosing messages. Also, it is useful for tracking presence.</p>
<p>You can't leave if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The Pubnub context. Can't be NULL. </td></tr>
    <tr><td class="paramname">channel</td><td>The string with the channel name (or comma-delimited list of channel names) to leave from. </td></tr>
    <tr><td class="paramname">channel_group</td><td>The string with the channel group name (or comma-delimited list of channel group names) to leave from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ac1ce31971f4afb40ee00ea34130923da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum pubnub_res pubnub_list_channel_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>channel_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lists all channels of a <code>channel_group</code>. This actually means "initiate a list_channel_group transaction". It can be thought of as a query against the "channel group database".</p>
<p>If transaction is successful, the response will be a available via <a class="el" href="pubnub__coreapi_8h.html#a08834b5041b308e7bc5747053c1020ed">pubnub_get_channel()</a> as one "channel", a JSON object with keys:</p>
<ul>
<li>"service": should be "channel-registry"</li>
<li>"status": the HTTP status of the operation (200 OK, 40x error, etc.)</li>
<li>"error": true on error, false on success</li>
<li>"payload": JSON object with keys "group" with value the string of the channel group name and "channels" with value a JSON array of strings with names of the channels that belong to the group</li>
</ul>
<p>You can't remove a channel group if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The Pubnub context. Can't be NULL. </td></tr>
    <tr><td class="paramname">channel_group</td><td>The channel group to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="af043957f0989781596c695b123f9686e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum pubnub_res pubnub_publish </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Publish the <code>message</code> (in JSON format) on <code>p</code> channel, using the <code>p</code> context. This actually means "initiate a publish
transaction".</p>
<p>You can't publish if a transaction is in progress in <code>p</code> context.</p>
<p>If transaction is not successful (<code>PNR_PUBLISH_FAILED</code>), you can get the string describing the reason for failure by calling <a class="el" href="pubnub__coreapi_8h.html#a60d7c7c38cd91b552df479ba21155c5c">pubnub_last_publish_result()</a>.</p>
<p>Keep in mind that the time token from the publish operation response is <em>not</em> parsed by the library, just relayed to the user. Only time-tokens from the subscribe operation are parsed by the library.</p>
<p>Also, for all error codes known at the time of this writing, the HTTP error will be set also, so the result of the Pubnub operation will not be <code>PNR_OK</code> (but you will still be able to get the result code and the description).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pubnub context. Can't be NULL </td></tr>
    <tr><td class="paramname">channel</td><td>The string with the channel (or comma-delimited list of channels) to publish to. </td></tr>
    <tr><td class="paramname">message</td><td>The message to publish, expected to be in JSON format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="aef6ec570028527de1869df05d67a347f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum pubnub_res pubnub_publishv2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>store_in_history</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eat_after_reading</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Publish the <code>message</code> (in JSON format) on <code>p</code> channel, using the <code>p</code> context, utilizing the v2 API. This actually means "initiate
a publish transaction".</p>
<p>Basically, this is an extension to the <a class="el" href="pubnub__coreapi_8h.html#af043957f0989781596c695b123f9686e">pubnub_publish()</a> (v1), with some additional options.</p>
<p>You can't publish if a transaction is in progress in <code>p</code> context.</p>
<p>The response</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pubnub context. Can't be NULL </td></tr>
    <tr><td class="paramname">channel</td><td>The string with the channel (or comma-delimited list of channels) to publish to. </td></tr>
    <tr><td class="paramname">message</td><td>The message to publish, expected to be in JSON format </td></tr>
    <tr><td class="paramname">store_in_history</td><td>If <code>false</code>, message will not be stored in history of the channel </td></tr>
    <tr><td class="paramname">eat_after_reading</td><td>If <code>true</code>, message will not be stored for delayed or repeated retrieval or display</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a0b4e32da7ba33152ed4addce7b6a54c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum pubnub_res pubnub_remove_channel_from_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>channel_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a <code>channel</code> from the <code>channel_group</code> . This actually means "initiate a remove_channel_from_channel_group
transaction". It can be thought of as an update against the "channel group database".</p>
<p>You can't remove the last channel from a channel group. To do that, remove the channel group itself.</p>
<p>If transaction is successful, the response will be a available via <a class="el" href="pubnub__coreapi_8h.html#a08834b5041b308e7bc5747053c1020ed">pubnub_get_channel()</a> as one "channel", a JSON object with keys:</p>
<ul>
<li>"service": should be "channel-registry"</li>
<li>"status": the HTTP status of the operation (200 OK, 40x error, etc.)</li>
<li>"error": true on error, false on success</li>
<li>"message": the string/message describing the status ("OK"...)</li>
</ul>
<p>You can't remove a channel from a channel group if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The Pubnub context. Can't be NULL. </td></tr>
    <tr><td class="paramname">channel_group</td><td>The channel to remove </td></tr>
    <tr><td class="paramname">channel_group</td><td>The channel group to remove from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a42d5ec4e620b8a9eea719445dbe6bd93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum pubnub_res pubnub_remove_channel_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>channel_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a <code>channel_group</code> and all its channels. This actually means "initiate a remove_channel_group transaction". It can be thought of as an update against the "channel group database".</p>
<p>If transaction is successful, the response will be a available via <a class="el" href="pubnub__coreapi_8h.html#a08834b5041b308e7bc5747053c1020ed">pubnub_get_channel()</a> as one "channel", a JSON object with keys:</p>
<ul>
<li>"service": should be "channel-registry"</li>
<li>"status": the HTTP status of the operation (200 OK, 40x error, etc.)</li>
<li>"error": true on error, false on success</li>
<li>"message": the string/message describing the status ("OK"...)</li>
</ul>
<p>You can't remove a channel group if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The Pubnub context. Can't be NULL. </td></tr>
    <tr><td class="paramname">channel_group</td><td>The channel group to remove</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a2289ad90d4d24a66f3407fb191e75281"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pubnub_set_auth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>auth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the authentication information of PubNub client context <code>p</code>. Pass NULL to unset.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>auth</code> is expected to be valid (ASCIIZ string) pointers throughout the use of context <code>p</code>, that is, until either you call pubnub_done() on <code>p</code>, or the otherwise stop using it (like when the whole software/ firmware stops working). So, the contents of the auth string is not copied to the Pubnub context <code>p</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="afc1e29aa8c82763709a5e7e53de35144"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum pubnub_res pubnub_set_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>channel_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uuid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets some state for the <code>channel</code> and/or  for a user, identified by <code>uuid</code>. This actually means "initiate a set
state transaction". It can be thought of as an update against the "presence database".</p>
<p>"State" has to be a JSON object (IOW, several "key-value" pairs).</p>
<p>If transaction is successful, the response will be a available via <a class="el" href="pubnub__coreapi_8h.html#ab6d4b0fa460d97a1e256e44e60df2447">pubnub_get()</a> as one message, a JSON object with following keys:</p>
<ul>
<li>"status": the HTTP status of the operation (200 OK, 40x error, etc.)</li>
<li>"message": the string/message describing the status ("OK"...)</li>
<li>"service": should be "Presence"</li>
<li>"payload" the state</li>
</ul>
<p>This will set the same state to all channels identified by <code>channel</code> and <code>channel_group</code>.</p>
<p>If <code>channel</code> is NULL, then <code>channel_group</code> cannot be NULL and you will set state only to the channel group(s). It goes both ways: if <code>channel_group</code> is NULL, then <code>channel</code> cannot be NULL and you will set state only to the channel(s).</p>
<p>You can't set state of channels if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The Pubnub context. Can't be NULL. </td></tr>
    <tr><td class="paramname">channel</td><td>The string with the channel name (or comma-delimited list of channel names) to set state for. </td></tr>
    <tr><td class="paramname">channel_group</td><td>The string with the channel name (or comma-delimited list of channel group names) to set state for. </td></tr>
    <tr><td class="paramname">uuid</td><td>The UUID of the user for which to set state for. If NULL, the current UUID of the <code>p</code> context will be used. </td></tr>
    <tr><td class="paramname">state</td><td>Has to be a JSON object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a561f8188e2aa23b44e5b0038a82a4198"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pubnub_set_uuid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uuid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the UUID identification of PubNub client context <code>p</code> to <code>uuid</code>. Pass NULL to unset.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>uuid</code> is expected to be valid (ASCIIZ string) pointers throughout the use of context <code>p</code>, that is, until either you call pubnub_done() on <code>p</code>, or the otherwise stop using it (like when the whole software/ firmware stops working). So, the contents of the <code>uuid</code> string is not copied to the Pubnub context <code>p</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a69951cee4056d416b531dcf0f03c5b42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum pubnub_res pubnub_state_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>channel_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uuid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets some state for the <code>channel</code> and/or  for a user, identified by <code>uuid</code>. This actually means "initiate a get
state transaction". It can be thought of as a query against the "presence database".</p>
<p>If transaction is successful, the response will be a available via <a class="el" href="pubnub__coreapi_8h.html#ab6d4b0fa460d97a1e256e44e60df2447">pubnub_get()</a> as one message, a JSON object with following keys:</p>
<ul>
<li>"status": the HTTP status of the operation (200 OK, 40x error, etc.)</li>
<li>"message": the string/message describing the status ("OK"...)</li>
<li>"service": should be "Presence"</li>
<li>"payload": if querying against one channel the gotten state (a JSON object), otherwise a JSON object with the key "channels" whose value is a JSON object with keys the name of the channels and their respective values JSON objects of the gotten state</li>
</ul>
<p>If <code>channel</code> is NULL, then <code>channel_group</code> cannot be NULL and you will get state only for the channel group(s). It goes both ways: if <code>channel_group</code> is NULL, then <code>channel</code> cannot be NULL and you will get state only for the channel(s).</p>
<p>You can't set state of channels if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The Pubnub context. Can't be NULL. </td></tr>
    <tr><td class="paramname">channel</td><td>The string with the channel name (or comma-delimited list of channel names) to set state for. </td></tr>
    <tr><td class="paramname">channel_group</td><td>The string with the channel name (or comma-delimited list of channel group names) to set state for. </td></tr>
    <tr><td class="paramname">uuid</td><td>The UUID of the user for which to set state for. If NULL, the current UUID of the <code>p</code> context will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a54c044b475d6902883e5ca41a1deabc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum pubnub_res pubnub_subscribe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>channel_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subscribe to <code>channel</code> and/or <code>channel_group</code>. This actually means "initiate a subscribe operation/transaction". The outcome is sent to the process that starts the transaction via process event <a class="el" href="pubnub__ntf__contiki_8h.html#a0e917c4bd15f229cff1783999a502499">pubnub_publish_event</a>, which is a good place to start reading the fetched message(s), via <a class="el" href="pubnub__coreapi_8h.html#ab6d4b0fa460d97a1e256e44e60df2447">pubnub_get()</a>.</p>
<p>Messages published on <code>channel</code> and/or <code>channel_group</code> since the last subscribe transaction will be fetched.</p>
<p>The <code>channel</code> and <code>channel_group</code> strings may contain multiple comma-separated channel (channel group) names, so only one call is needed to fetch messages from multiple channels (channel groups).</p>
<p>If <code>channel</code> is NULL, then <code>channel_group</code> cannot be NULL and you will subscribe only to the channel group(s). It goes both ways: if <code>channel_group</code> is NULL, then <code>channel</code> cannot be NULL and you will subscribe only to the channel(s).</p>
<p>You can't subscribe if a transaction is in progress on the context.</p>
<p>Also, you can't subscribe if there are unread messages in the context (you read messages with <a class="el" href="pubnub__coreapi_8h.html#ab6d4b0fa460d97a1e256e44e60df2447">pubnub_get()</a>).</p>
<dl class="section note"><dt>Note</dt><dd>Some of the subscribed messages may be lost when calling publish() after a subscribe() on the same context or subscribe() on different channels in turn on the same context. But typically, you will want two separate contexts for publish and subscribe anyway. If you are changing the set of channels you subscribe to, you should first call <a class="el" href="pubnub__coreapi_8h.html#a327aa6bbf7efac398dc453d31ba8097d">pubnub_leave()</a> on the old set.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pubnub context. Can't be NULL </td></tr>
    <tr><td class="paramname">channel</td><td>The string with the channel name (or comma-delimited list of channel names) to subscribe to. </td></tr>
    <tr><td class="paramname">channel_group</td><td>The string with the channel group name (or comma-delimited list of channel group names) to subscribe to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="pubnub__coreapi_8h.html#ab6d4b0fa460d97a1e256e44e60df2447">pubnub_get</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a748bcf6a8df43e443100db9a9e6fe759"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum pubnub_res pubnub_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current Pubnub time token . This actually means "initiate
a time transaction". Since time token is in the response to most Pubnub REST API calls, this is reserved mostly when you want to get a high-quality seed for a random number generator, or some such thing.</p>
<p>If transaction is successful, the gotten time will be the only message you can get with <a class="el" href="pubnub__coreapi_8h.html#ab6d4b0fa460d97a1e256e44e60df2447">pubnub_get()</a>. It will be a (large) JSON integer.</p>
<p>You can't get time if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The Pubnub context. Can't be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a1ca62c2a7f676cd084f335f983b6f1eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const* pubnub_uuid_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> const *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the UUID identification of PubNub client context <code>p</code>. After <a class="el" href="pubnub__coreapi_8h.html#af3efadf99ac4b832949265a675ec87b0">pubnub_init()</a>, it will return <code>NULL</code> until you change it to non-<code>NULL</code> via <a class="el" href="pubnub__coreapi_8h.html#a561f8188e2aa23b44e5b0038a82a4198">pubnub_set_uuid()</a>. </p>

</div>
</div>
<a class="anchor" id="a4086aeedb45d944d4b68ab3e0407e0f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum pubnub_res pubnub_where_now </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpubnub.html">pubnub_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>uuid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the currently present users on a <code>channel</code> and/or <code>channel_group</code>. This actually means "initiate a here_now
transaction". It can be thought of as a query against the "presence database".</p>
<p>If transaction is successful, the response will be a available via <a class="el" href="pubnub__coreapi_8h.html#ab6d4b0fa460d97a1e256e44e60df2447">pubnub_get()</a> as one message, a JSON object with keys:</p>
<ul>
<li>"status": the HTTP status of the operation (200 OK, 40x error, etc.)</li>
<li>"message": the string/message describing the status ("OK"...)</li>
<li>"service": should be "Presence"</li>
<li>"payload": JSON object with a key "channels" which is an array of channels this user is present in</li>
</ul>
<p>You can't get channel presence for the user if a transaction is in progress on the context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The Pubnub context. Can't be NULL. </td></tr>
    <tr><td class="paramname">uuid</td><td>The UUID of the user to get the channel presence. If NULL, the current UUID of the <code>p</code> context will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>#PNR_STARTED on success, an error otherwise </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Aug 18 2015 21:05:05 for Pubnub C SDK by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
